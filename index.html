<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - shaders - ocean</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div id="container"></div>
    <div id="info">
      <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
      - webgl ocean
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      import "./src/style.css";

      import * as THREE from "three";
      import * as Tone from "tone";

      // import Stats from "three/addons/libs/stats.module.js";

      import { GUI } from "three/addons/libs/lil-gui.module.min.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { Water } from "three/addons/objects/Water.js";
      import { Sky } from "three/addons/objects/Sky.js";

      let container;
      let camera, scene, renderer;
      let controls, water, sun;

      //
      async function startAudio() {
        await Tone.start(); // Enable the AudioContext
        console.log("Audio is now enabled!");

        // Create brown noise and pink noise
        const brownNoise = new Tone.Noise("brown").start();
        const pinkNoise = new Tone.Noise("pink").start();

        // Gain nodes for independent volume control
        const brownGain = new Tone.Gain(0).toDestination();
        const pinkGain = new Tone.Gain(0).toDestination();

        // Connect noises to their respective gain nodes
        brownNoise.connect(brownGain);
        pinkNoise.connect(pinkGain);

        // LFO for brown noise volume
        const brownLFO = new Tone.LFO({
          type: "sine",
          min: 0.2,
          max: 0.8,
          frequency: 0.05, // Slow ebb for brown noise
        })
          .connect(brownGain.gain)
          .start();

        // LFO for pink noise volume
        const pinkLFO = new Tone.LFO({
          type: "sine",
          min: 0.1,
          max: 0.6,
          frequency: 0.08, // Slightly faster for pink noise
        })
          .connect(pinkGain.gain)
          .start();

        // Start the transport
        Tone.Transport.start();

        // Remove event listeners after audio starts
        document.body.removeEventListener("click", startAudio);
        document.body.removeEventListener("touchstart", startAudio);

        console.log("Portable ocean started!");
      }

      // Add click or touchstart event listeners to the whole document
      document.body.addEventListener("click", startAudio);
      document.body.addEventListener("touchstart", startAudio);
      //

      init();

      function init() {
        container = document.getElementById("container");

        //

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.5;
        container.appendChild(renderer.domElement);

        //

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          55,
          window.innerWidth / window.innerHeight,
          1,
          20000
        );
        camera.position.set(30, 30, 100);

        //

        sun = new THREE.Vector3();

        // Water

        const waterGeometry = new THREE.PlaneGeometry(10000, 10000);

        water = new Water(waterGeometry, {
          textureWidth: 512,
          textureHeight: 512,
          waterNormals: new THREE.TextureLoader().load(
            "textures/waternormals.jpg",
            function (texture) {
              texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            }
          ),
          sunDirection: new THREE.Vector3(),
          sunColor: 0xffffff,
          waterColor: 0x201e6f,
          distortionScale: 3.7,
          fog: scene.fog !== undefined,
        });

        water.rotation.x = -Math.PI / 2;

        scene.add(water);

        // Skybox

        const sky = new Sky();
        sky.scale.setScalar(10000);
        scene.add(sky);

        const skyUniforms = sky.material.uniforms;

        skyUniforms["turbidity"].value = 10;
        skyUniforms["rayleigh"].value = 2;
        skyUniforms["mieCoefficient"].value = 0.005;
        skyUniforms["mieDirectionalG"].value = 0.8;

        const parameters = {
          elevation: 2,
          azimuth: 180,
        };

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        const sceneEnv = new THREE.Scene();

        let renderTarget;

        function updateSun() {
          const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
          const theta = THREE.MathUtils.degToRad(parameters.azimuth);

          sun.setFromSphericalCoords(1, phi, theta);

          sky.material.uniforms["sunPosition"].value.copy(sun);
          water.material.uniforms["sunDirection"].value.copy(sun).normalize();

          if (renderTarget !== undefined) renderTarget.dispose();

          sceneEnv.add(sky);
          renderTarget = pmremGenerator.fromScene(sceneEnv);
          scene.add(sky);

          scene.environment = renderTarget.texture;
        }

        updateSun();

        //

        controls = new OrbitControls(camera, renderer.domElement);
        controls.maxPolarAngle = Math.PI * 0.495;
        controls.target.set(0, 10, 0);
        controls.minDistance = 40.0;
        controls.maxDistance = 200.0;
        controls.update();

        //

        // stats = new Stats();
        // container.appendChild(stats.dom);

        // GUI
        /*
        const gui = new GUI();

        const folderSky = gui.addFolder("Sky");
        folderSky.add(parameters, "elevation", 0, 90, 0.1).onChange(updateSun);
        folderSky
          .add(parameters, "azimuth", -180, 180, 0.1)
          .onChange(updateSun);
        folderSky.open();

        const waterUniforms = water.material.uniforms;

        const folderWater = gui.addFolder("Water");
        folderWater
          .add(waterUniforms.distortionScale, "value", 0, 8, 0.1)
          .name("distortionScale");
        folderWater.add(waterUniforms.size, "value", 0.1, 10, 0.1).name("size");
        folderWater.open();
*/

        //

        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        render();
        // stats.update();
      }

      function render() {
        const time = performance.now() * 0.001;

        water.material.uniforms["time"].value += 1.0 / 60.0;

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
